<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
 <title>Proptest strategies the hard way | The bytes // they want you</title>
 <meta name="description" content="@pnevyk's words on programming">
 <link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" rel="stylesheet">
 <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet" media="(prefers-color-scheme: dark)">
 <link href="https://unpkg.com/prismjs@1.20.0/themes/prism.css" rel="stylesheet" media="(prefers-color-scheme: light)">
 <link href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" rel="stylesheet" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
 <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
 <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;700&display=swap" rel="stylesheet">
 <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
 <link href="/static/css/main.css" rel="stylesheet">
 
 <link rel="canonical" href="https://pnevyk.github.io/posts/proptest-strategies-the-hard-way/" />
 
</head>
<body lang="en">
 <header>
 <h1><a class="title" href="/">The bytes // they want you</a></h1>
 <p class="subtitle"><a href="https://twitter.com/pnevyk" target="_blank">@pnevyk’s</a> words on programming</p>
 </header>
 <main id="main">
 <div id="progress"></div>
<article>
 <h1>Proptest strategies the hard way</h1>
 <div class="metadata">
 <span>Published on <em><time datetime="2023-06-06">6 June 2023</time></em></span>
 <span>About <em>21 min</em> reading time</span>
 </div>
 <div class="metadata">
 
 Topics:
 
 
 <em>#rust</em>
 
 <em>#walk-through</em>
 
 <em>#testing</em>
 
 </div>

 <p><a href="https://crates.io/crates/proptest">Proptest</a> is a Rust crate for <a href="https://altsysrq.github.io/proptest-book/intro.html#what-is-property-testing">property-based testing</a>. It provides data generators for standard types and ways how to
<a href="https://altsysrq.github.io/proptest-book/proptest/tutorial/macro-prop-compose.html">combine</a> and
<a href="https://altsysrq.github.io/proptest-book/proptest/tutorial/transforming-strategies.html">transform</a> those to create instances of your own types.
You can also use <a href="https://altsysrq.github.io/proptest-book/proptest-derive/index.html">proptest-derive</a> crate for implementing the generator for your type automatically.
All this is useful, but in more complicated cases it makes sense to implement this manually.
And this post shows how to do that.
It is based on my experience writing generators for <a href="https://github.com/pnevyk/gryf/blob/main/src/infra/proptest.rs">gryf</a> graph library.</p>
<figure><img src="/static/img/chess.jpg" style="max-width: 100%" alt=""Chess is an abstract strategy game" -- Wikipedia. Photo by Felix Mittermeier on Unsplash
"><figcaption><p>“Chess is an abstract strategy game” – Wikipedia. Photo by <a href="https://unsplash.com/@felix_mittermeier">Felix Mittermeier</a> on <a href="https://unsplash.com/photos/nAjil1z3eLk">Unsplash</a></p>
</figcaption></figure>
<p>The preliminary for reading this is a basic familiarity with property-based testing in general and proptest crate in particular.
<a href="https://altsysrq.github.io/proptest-book/intro.html">Proptest book</a> provides a very nice introduction to both.
This is <em>not</em> a tutorial for either.</p>
<aside class="warning"><p>In most situations when testing with proptest, you will get very far with just <code>fn foo() -&gt; impl Strategy&lt;Value = Foo&gt;</code> or <a href="https://altsysrq.github.io/proptest-book/proptest/tutorial/macro-prop-compose.html">prop_compose!</a> macro.
If you can, stick to these simpler approaches,
and use manual implementation (the topic of this post) only when it brings considerable benefits.</p>
</aside><details class="toc">
<summary>Table of contents</summary>
<nav class="table-of-contents"><ul><li><a href="#strategy-and-valuetree-traits">Strategy and ValueTree traits </a></li><li><a href="#shrinking-as-a-state-machine">Shrinking as a state machine </a></li><li><a href="#internal-representation">Internal representation </a><ul><li><a href="#graphs">Graphs </a></li><li><a href="#matrices">Matrices </a></li></ul></li><li><a href="#generation-implementation">Generation implementation </a><ul><li><a href="#floats">Floats </a></li><li><a href="#characters">Characters </a></li><li><a href="#strings">Strings </a></li><li><a href="#hashmaps">HashMaps </a></li><li><a href="#summary">Summary </a></li></ul></li><li><a href="#shrinking-implementation">Shrinking implementation </a></li><li><a href="#miscellaneous-remarks">Miscellaneous remarks </a></li><li><a href="#conclusion">Conclusion </a></li></ul></nav></details>
<h2 id="strategy-and-valuetree-traits"><code>Strategy</code> and <code>ValueTree</code> traits <a class="header-anchor" href="#strategy-and-valuetree-traits">#</a></h2>
<p>The core for generating data in proptest lies in
<a href="https://docs.rs/proptest/latest/proptest/strategy/trait.Strategy.html"><code>Strategy</code></a> and
<a href="https://docs.rs/proptest/latest/proptest/strategy/trait.ValueTree.html"><code>ValueTree</code></a> traits.
<code>Strategy</code> knows how to create a <code>ValueTree</code>, which carries the generated value and knows how to simplify it.</p>
<figure><img src="/static/img/strategy-valuetree.png" style="max-width: 100%" alt="Strategy generates a value tree, which carries the generated value and knows how to simplify it.
"><figcaption><p>Strategy generates a value tree, which carries the generated value and knows how to simplify it.</p>
</figcaption></figure>
<p>This is an important difference from <a href="https://crates.io/crates/quickcheck">quickcheck</a> crate,
where you can have only a single implementation of <a href="https://docs.rs/quickcheck/latest/quickcheck/trait.Arbitrary.html"><code>Arbitrary</code></a> for a type,
which specifies how a value is generated <em>and simplified</em>.
In proptest, you can implement multiple different strategies for a type,
which will share the shrinking implementation defined by the value tree<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a><span class="footnote-content">
Technically, you can also have multiple <code>ValueTree</code> implementations for a type.
But I am not sure where it would be useful in practice.
Apart from special adapters like <a href="https://docs.rs/proptest/latest/proptest/strategy/struct.NoShrink.html"><code>NoShrink</code></a>.</span></sup>.</p>
<figure><img src="/static/img/multiple-strategies.png" style="max-width: 100%" alt="There can be multiple strategies generating the same value tree.
"><figcaption><p>There can be multiple strategies generating the same value tree.</p>
</figcaption></figure>
<p>Let’s see the actual definition of these two traits:</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">Strategy</span><span class="token punctuation">:</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Debug</span> <span class="token punctuation">{</span><br>    <span class="token keyword">type</span> <span class="token class-name">Tree</span><span class="token punctuation">:</span> <span class="token class-name">ValueTree</span><span class="token operator">&lt;</span><span class="token class-name">Value</span> <span class="token operator">=</span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Value</span><span class="token operator">></span><span class="token punctuation">;</span><br>    <span class="token keyword">type</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Debug</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">fn</span> <span class="token function-definition function">new_tree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> runner<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token class-name">TestRunner</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">NewTree</span><span class="token operator">&lt;</span><span class="token keyword">Self</span><span class="token operator">></span><span class="token punctuation">;</span><br><br>    <span class="token comment">// Provided methods</span><br>    <span class="token comment">// ...</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">pub</span> <span class="token keyword">type</span> <span class="token class-name">NewTree</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token class-name">Result</span><span class="token operator">&lt;&lt;</span><span class="token class-name">S</span> <span class="token keyword">as</span> <span class="token class-name">Strategy</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token class-name">Tree</span><span class="token punctuation">,</span> <span class="token class-name">Reason</span><span class="token operator">></span><span class="token punctuation">;</span><br><br><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token class-name">ValueTree</span> <span class="token punctuation">{</span><br>    <span class="token keyword">type</span> <span class="token class-name">Value</span><span class="token punctuation">:</span> <span class="token namespace">fmt<span class="token punctuation">::</span></span><span class="token class-name">Debug</span><span class="token punctuation">;</span><br><br>    <span class="token keyword">fn</span> <span class="token function-definition function">current</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span><span class="token punctuation">::</span><span class="token class-name">Value</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">simplify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span><span class="token punctuation">;</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">complicate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Note that there is also the <a href="https://docs.rs/proptest/latest/proptest/arbitrary/trait.Arbitrary.html"><code>Arbitrary</code></a> trait, but it is not fundamental for generating and shrinking the values.
It is optional.
If implemented, it represents a <em>canonical</em> strategy for a type and enables using <code>any::&lt;MyType&gt;()</code> (and relatives) for producing a strategy.</p>
<h2 id="shrinking-as-a-state-machine">Shrinking as a state machine <a class="header-anchor" href="#shrinking-as-a-state-machine">#</a></h2>
<p>In the trait definition of <code>ValueTree</code> there are <code>simplify</code> and <code>complicate</code> methods, both taking <code>&amp;mut self</code>.
This might be surprising at first – why would we want to complicate things? Aren’t they complicated enough?</p>
<p>The reason is that a value tree is actually some form of a <em>state machine</em> that is used for searching over the input space of the type.
The state is represented by the current value and some metadata, as we will see later.
The test runner then uses these two actions to converge into a value that is (potentially) simpler than the originally found but still causes the test to fail.
Thanks to <code>complicate</code>, the state machine can attempt to do larger steps during simplification,
and (partially) roll back if the value is not failing anymore.</p>
<figure><img src="/static/img/simplify-complicate.png" style="max-width: 100%" alt="Value tree knows not only how to simplify a value, but also how to complicate it.
Using these actions, the test runner tries to converge into a minimal reproducer.
"><figcaption><p>Value tree knows not only how to simplify a value, but also how to complicate it.
Using these actions, the test runner tries to converge into a minimal reproducer.</p>
</figcaption></figure>
<p>From the <a href="https://docs.rs/proptest/latest/proptest/strategy/trait.ValueTree.html">documentation</a> for the <code>ValueTree</code> trait (emphasis mine):</p>
<blockquote>
<p>Conceptually, a ValueTree represents a spectrum between a “minimally complex” value and a starting, randomly-chosen value.
For values such as numbers, this can be thought of as a simple <strong>binary search</strong>, and this is how the ValueTree state machine is defined.</p>
</blockquote>
<p>Using binary search makes sense. You have a value that you know that it’s <em>failing</em> – this is the initial high.
Your type (most likely) also has a <em>trivial</em> value (i.e., “minimally complex”, e.g. an empty string or 0) – this is the initial low.
The goal is to find a value that is <em>as minimal as possible but still failing</em>.
Binary search is an efficient way for achieving this goal
(it is for example what <a href="https://git-scm.com/docs/git-bisect">git bisect</a> uses for finding the commit that introduced a bug).</p>
<figure><img src="/static/img/simplification-line.png" style="max-width: 100%" alt="For types whose values have a strict total order, binary search is the most efficient way to find the minimal reproducer.
"><figcaption><p>For types whose values have a strict total order, binary search is the most efficient way to find the minimal reproducer.</p>
</figcaption></figure>
<p>The binary search analogy is great for understanding the simplification process in proptest.
However, for more complicated types (like graphs, but even vectors), the values on a “complexity scale” between failing and trivial may not lie on a straight line.
Imagine a vector <em>[1, 2, 3]</em>. Either of the elements can be removed resulting in <em>[2, 3]</em>, <em>[1, 3]</em> or <em>[1, 2]</em>, respectively, and all these simplifications are valid options.
In such situations, you could think of it more as a <a href="https://en.wikipedia.org/wiki/Lattice_(order)">lattice</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a><span class="footnote-content">Finally I can use this term outside of the university!</span></sup>, as illustrated in the following picture.</p>
<figure><img src="/static/img/simplification-lattice.png" style="max-width: 100%" alt="An illustration of a more complicated simplification process.
"><figcaption><p>An illustration of a more complicated simplification process.</p>
</figcaption></figure>
<p>During simplification, you take one branch and test the value.
If it still causes a failure, you continue going down.
Once you reach a value that doesn’t fail, you take a step back and try the next branch.
When you tried all branches from a value and none of them caused a failure, you got to <em>a</em> minimal reproducer<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a><span class="footnote-content">This claim is not really true in general.
Possibly, there could exist a branch from one of the value’s ancestors which could lead to an even smaller reproducer but was not tried.
If this is true for your type, consider making the extra effort to make the simplification traverse all possible paths so you are guaranteed to get an actually minimal reproducer.</span></sup>.</p>
<p>Now I drew the illustration with values that have multiple “parents”.
This represents a situation where you can get to a value in different ways.
In a vector with at least two elements, you can get to an empty vector by removing the elements in different orders.
But in the implementation of <code>ValueTree</code>, you have to make sure that calling <code>complicate</code> will get you back to the parent on which you previously called <code>simplify</code>, not an arbitrary parent.
Otherwise, you could introduce cycles and your shrinking process might never terminate.</p>
<h2 id="internal-representation">Internal representation <a class="header-anchor" href="#internal-representation">#</a></h2>
<p>The design of proptest, in particular the existence of <code>ValueTree</code> encapsulation of the generated value,
allows thinking about how to represent the value under the hood.
Because in more complicated cases, it may be valuable to choose a representation that is not the actual type it represents.
Why? Because we must not forget that we will eventually be asked to simplify the values of our type<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a><span class="footnote-content">
Unless you are the type of a programmer who <a href="https://github.com/rust-lang/regex/discussions/994#discussioncomment-5948689">writes code without bugs</a>.</span></sup>,
and if our type is complex, it may not be an easy task.</p>
<p>So we want to generate value trees that satisfy the following goals:</p>
<ol>
<li>It is <em>fast</em> to produce the value of the target type corresponding to the value tree.</li>
<li>It is reasonably <em>easy</em> to manipulate the value tree during the shrinking process.</li>
</ol>
<p>These two might be in tension, so the goal is to find a good balance.</p>
<figure><img src="/static/img/representation-tension.png" style="max-width: 100%" alt="The representation must be fast to convert to the value itself as well as convenient to manipulate during the shrinking process. These two requirements might be in tension.
"><figcaption><p>The representation must be fast to convert to the value itself as well as convenient to manipulate during the shrinking process. These two requirements might be in tension.</p>
</figcaption></figure>
<p>Let’s see some examples…</p>
<h3 id="graphs">Graphs <a class="header-anchor" href="#graphs">#</a></h3>
<p>In gryf, the <a href="https://github.com/pnevyk/gryf/blob/4518875bcaaa296b5ccfa4b0e6943a9fb5dfd455/src/infra/proptest.rs#L41-L48">value tree</a> is represented by (simplified)</p>
<ul>
<li><code>vertices: Vec&lt;V&gt;</code> and <code>edges: Vec&lt;(usize, usize, E)&gt;</code>‚</li>
<li><code>removed_vertices: HashSet&lt;usize&gt;</code> and <code>removed_edges: HashSet&lt;usize&gt;</code>.</li>
</ul>
<p>Generating the representation of a graph is filling <code>vertices</code> and <code>edges</code> vectors (the details of this are not important here).
Producing the real graph from it consists of these steps:</p>
<ol>
<li>Add all vertices from <code>vertices</code>, but only if their indexes are not in <code>removed_vertices</code>.</li>
<li>Add all edges from <code>edges</code>, but only if their indexes are not in <code>removed_edges</code> or neither of their endpoints is in <code>removed_vertices</code>.</li>
</ol>
<p>Simplifying and complicating the graph is then done by adding and removing elements from <code>removed_vertices</code> or <code>removed_edges</code>.
This is much simpler than if we needed to manipulate a graph instance itself.
The main complication would be restoring the graph to its original form after removing a vertex,
where you would also need to restore all edges that led to that vertex.
Producing the graph and managing the removed sets is sufficiently fast.</p>
<aside class="note"><h3>by the way&hellip;</h3><div><p>The strategy for <code>Vec</code> in proptest uses reverse approach for keeping track of still-present elements.
It <a href="https://github.com/proptest-rs/proptest/blob/0b2628c6ab74f6b2602c32532dea9909188f2910/proptest/src/collection.rs#L546">has</a> <code>included_elements</code> field which is a bit set.
Initially, all bits in it are set to true.
During shrinking, those corresponding to “removed” elements are switched to false.</p>
<p>There are some trade-offs: Bit set is significantly faster and more space-efficient than <code>HashSet&lt;usize&gt;</code>.
On the other hand, for every newly generated value, the set of included elements must be initialized covering the whole vector, while initializing an empty hash set is basically noop.
I see it as that using bit set for included elements penalizes the value generation, while using hash set for removed elements penalizes the value shrinking.
I am willing to sacrifice some efficiency during shrinking if that means faster tests in happy case.
Life is happy most of the time after all, <a href="https://i.imgflip.com/1xqcvl.jpg">isn’t it</a>?</p>
<p>But there is a compromise, the bit set could be initialized lazily when a first bit is set to false.
This would bring the good from both worlds.</p>
</div></aside><h3 id="matrices">Matrices <a class="header-anchor" href="#matrices">#</a></h3>
<p>The value tree for a matrix type could be represented by</p>
<ul>
<li><code>elements: Vec&lt;T&gt;</code> (a linear representation of the matrix, which is a <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">common technique</a>, having length of <em>n_rows</em> x <em>n_cols</em>),</li>
<li><code>removed_rows: HashSet&lt;usize&gt;</code> and <code>removed_cols: HashSet&lt;usize&gt;</code>.</li>
</ul>
<p>Filling the matrix is done by iterating over the elements,
calculating the row (<code>index / n_cols</code>) and column (<code>index % n_cols</code>) for the element
and adding the element to the matrix only if the row or column are not in <code>removed_rows</code> and <code>removed_cols</code>, respectively.</p>
<p>Although it would be somewhat straightforward to actually remove a row from the elements vector using <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.drain"><code>Vec::drain</code></a>,
there is no such a nice way to remove a column (which is scattered over the vector),
and adding both back during complication would not be fun either, and likely less efficient in terms of the whole process (don’t quote me on that).</p>
<h2 id="generation-implementation">Generation implementation <a class="header-anchor" href="#generation-implementation">#</a></h2>
<p>This could be a one-paragraph section:
Use the <a href="https://docs.rs/rand/latest/rand/trait.Rng.html"><code>rand::Rng</code></a> generator
accessible via <a href="https://docs.rs/proptest/latest/proptest/test_runner/struct.TestRunner.html#method.rng"><code>TestRunner::rng</code></a>
to generate the internal representation of your choice and return it.
Nevertheless, let’s see how are generators implemented for some primitives and standard types in proptest itself.</p>
<p>If you are not interested in implementation details, you might want to skip to the <a href="#summary">summary</a> of general techniques.</p>
<h3 id="floats">Floats <a class="header-anchor" href="#floats">#</a></h3>
<p>The source for generating a float is <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/num.rs#L608-L675">here</a>.
The strategy holds the set of allowed float types (positive, normal, subnormal, infinite, …).
So it is possible to customize the strategy to produce values from desired categories.
From a high level, the strategy generates random bits of the float’s bit-width,
which is then refined to comply with the allowed float types.</p>
<p>It starts with defining some helper masks (substitute <code>$typ</code> with <code>f32</code> or <code>f64</code>, and see the <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/num.rs#L413-L429">definition</a> of used constants if you are interested):</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> sign_mask <span class="token operator">=</span> <span class="token keyword">if</span> flags<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">FloatTypes</span><span class="token punctuation">::</span><span class="token constant">NEGATIVE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">SIGN_MASK</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token number">0</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> sign_or <span class="token operator">=</span> <span class="token keyword">if</span> flags<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">FloatTypes</span><span class="token punctuation">::</span><span class="token constant">POSITIVE</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token number">0</span><br><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>    <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">SIGN_MASK</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span><br><br><span class="token keyword">let</span> quiet_or <span class="token operator">=</span> <span class="token punctuation">::</span><span class="token namespace">core<span class="token punctuation">::</span></span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">NAN</span><span class="token punctuation">.</span><span class="token function">to_bits</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><br>    <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> signaling_or <span class="token operator">=</span> <span class="token punctuation">(</span>quiet_or <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span><br>    <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span><span class="token punctuation">;</span></code></pre>
<p>This is then followed by generating some more helper masks and flags for a particular class, selected by a weighted choice from allowed classes:</p>
<pre class="language-rust"><code class="language-rust"><span class="token macro property">macro_rules!</span> weight <span class="token punctuation">{</span><br>    <span class="token punctuation">(</span><span class="token variable">$case</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">ident</span><span class="token punctuation">,</span> <span class="token variable">$weight</span><span class="token punctuation">:</span><span class="token fragment-specifier punctuation">expr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> flags<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">FloatTypes</span><span class="token punctuation">::</span><span class="token variable">$case</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token variable">$weight</span><br>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>            <span class="token number">0</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">let</span> <span class="token punctuation">(</span>class_mask<span class="token punctuation">,</span> class_or<span class="token punctuation">,</span> allow_edge_exp<span class="token punctuation">,</span> allow_zero_mant<span class="token punctuation">)</span> <span class="token operator">=</span><br>    <span class="token macro property">prop_oneof!</span><span class="token punctuation">[</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">NORMAL</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span> <span class="token operator">|</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">MANTISSA_MASK</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><br>              <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">SUBNORMAL</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">MANTISSA_MASK</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">ZERO</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">INFINITE</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">QUIET_NAN</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">MANTISSA_MASK</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> quiet_or<span class="token punctuation">,</span><br>              <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>        <span class="token macro property">weight!</span><span class="token punctuation">(</span><span class="token constant">SIGNALING_NAN</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token class-name">Just</span><span class="token punctuation">(</span><br>            <span class="token punctuation">(</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">MANTISSA_MASK</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">,</span> signaling_or<span class="token punctuation">,</span><br>              <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">new_tree</span><span class="token punctuation">(</span>runner<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>This part of the code uses <a href="https://docs.rs/proptest/1.0.0/proptest/prelude/macro.prop_oneof.html"><code>prop_oneof!</code></a> macro
which produces a strategy that performs the choice.
In general, you can use other strategies as building blocks inside your strategy.
Note however that you lose the shrinker for the value unless you store the value tree itself produced by the strategy.</p>
<p>Then a random bit representation is generated (substitute <code>&lt;$typ as FloatLayout&gt;::Bits</code> with <code>u32</code> or <code>u64</code>):</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token keyword">mut</span> generated_value<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token variable">$typ</span> <span class="token keyword">as</span> <span class="token class-name">FloatLayout</span><span class="token operator">></span><span class="token punctuation">::</span><span class="token class-name">Bits</span> <span class="token operator">=</span><br>    runner<span class="token punctuation">.</span><span class="token function">rng</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>The bits are then manipulated using the bit masks produced before:</p>
<pre class="language-rust"><code class="language-rust">generated_value <span class="token operator">&amp;=</span> sign_mask <span class="token operator">|</span> class_mask<span class="token punctuation">;</span><br>generated_value <span class="token operator">|=</span> sign_or <span class="token operator">|</span> class_or<span class="token punctuation">;</span><br><span class="token keyword">let</span> exp <span class="token operator">=</span> generated_value <span class="token operator">&amp;</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span><span class="token punctuation">;</span><br><span class="token keyword">if</span> <span class="token operator">!</span>allow_edge_exp <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> exp <span class="token operator">||</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span> <span class="token operator">==</span> exp<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    generated_value <span class="token operator">&amp;=</span> <span class="token operator">!</span><span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_MASK</span><span class="token punctuation">;</span><br>    generated_value <span class="token operator">|=</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">EXP_ZERO</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token keyword">if</span> <span class="token operator">!</span>allow_zero_mant <span class="token operator">&amp;&amp;</span><br>    <span class="token number">0</span> <span class="token operator">==</span> generated_value <span class="token operator">&amp;</span> <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token constant">MANTISSA_MASK</span><br><span class="token punctuation">{</span><br>    generated_value <span class="token operator">|=</span> <span class="token number">1</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>Finally, the <code>BinarySearch</code> value tree is returned with float converted from the bits:</p>
<pre class="language-rust"><code class="language-rust"><span class="token class-name">Ok</span><span class="token punctuation">(</span><span class="token class-name">BinarySearch</span><span class="token punctuation">::</span><span class="token function">new_with_types</span><span class="token punctuation">(</span><br>    <span class="token variable">$typ</span><span class="token punctuation">::</span><span class="token function">from_bits</span><span class="token punctuation">(</span>generated_value<span class="token punctuation">)</span><span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>This example shows these three techniques:</p>
<ol>
<li>Using other strategies as building blocks.</li>
<li>Refining a random value according to the requirements specified by the strategy parameters.</li>
<li>Using a different representation during generation (<code>u32</code> or <code>u64</code>). Although this representation is converted into the target type eagerly when constructing the value tree. It’s because in this case, it makes sense to do the binary search directly on the target type.</li>
</ol>
<h3 id="characters">Characters <a class="header-anchor" href="#characters">#</a></h3>
<p>The core of generating a <code>char</code> is <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/char.rs#L103-L145">here</a>. It is a function that takes</p>
<ul>
<li>random values generator,</li>
<li>set of special characters that are considered difficult to handle in some contexts (see the list <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/char.rs#L37-L53">here</a>, it’s interesting),</li>
<li>preferred char ranges (generation is biased towards these to some extent), and</li>
<li>allowed char ranges (the generated character must be within one of these ranges),</li>
</ul>
<p>and returns the <code>(base, offset)</code> pair, where the produced character is <code>char::from_u32(base + offset)</code>.
The <code>base</code> value is used for <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/char.rs#L261-L274">choosing</a> a somehow more clever <code>low</code> bound for the shrinking process.</p>
<p>The generation proceeds as follows.
First, there is a 50% chance that a special character is chosen (but only if it is included in allowed ranges):</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token operator">!</span>special<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> rnd<span class="token punctuation">.</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> s <span class="token operator">=</span> special<span class="token punctuation">[</span>rnd<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span>special<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">in_range</span><span class="token punctuation">(</span>ranges<span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>If a special character is not chosen, then there is a 50% chance that the character is chosen from one of the preferred ranges (but again, only if it is included in allowed ranges):</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">if</span> <span class="token operator">!</span>preferred<span class="token punctuation">.</span><span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> rnd<span class="token punctuation">.</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> range <span class="token operator">=</span> preferred<span class="token punctuation">[</span>rnd<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span>preferred<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">::</span><span class="token namespace">core<span class="token punctuation">::</span></span><span class="token keyword">char</span><span class="token punctuation">::</span><span class="token function">from_u32</span><span class="token punctuation">(</span><br>        rnd<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">..</span><span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">in_range</span><span class="token punctuation">(</span>ranges<span class="token punctuation">,</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>            <span class="token keyword">return</span> ret<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>If neither of the preferred ranges is used, the code returns a random character from the allowed ranges.
Note that not every <code>u32</code> value is a valid UTF−8 character, so <code>char::from_u32(random_u32)</code> can fail.
In that case, the code tries to generate a new random value.</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span><span class="token number">65_536</span> <span class="token punctuation">{</span><br>    <span class="token keyword">let</span> range <span class="token operator">=</span> ranges<span class="token punctuation">[</span>rnd<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">..</span>ranges<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">::</span><span class="token namespace">core<span class="token punctuation">::</span></span><span class="token keyword">char</span><span class="token punctuation">::</span><span class="token function">from_u32</span><span class="token punctuation">(</span><br>        rnd<span class="token punctuation">.</span><span class="token function">gen_range</span><span class="token punctuation">(</span><span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">..</span><span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> ch <span class="token keyword">as</span> <span class="token keyword">u32</span> <span class="token operator">-</span> <span class="token operator">*</span>range<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>There is also a fallback if there was no success even after a large number of attempts:</p>
<pre class="language-rust"><code class="language-rust"><span class="token punctuation">(</span><span class="token operator">*</span>ranges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></code></pre>
<p>This example shows these two techniques:</p>
<ol>
<li>Bias towards supposed edge cases. This arguably increases the chance of finding a failing input, but it must not be excessive, because that would artificially narrow the search space.</li>
<li>Handling invalid values produced by the random generator. The strategy should not fail in such cases if it can try harder or if there is a way how to produce at least something.</li>
</ol>
<h3 id="strings">Strings <a class="header-anchor" href="#strings">#</a></h3>
<p>String generation in proptest is interesting in that the shape of the strings is constrained by a regular expression.
That is, the strategy represented by <code>"[0-9]{4}-[0-9]{2}-[0-9]{2}"</code> will only generate strings that contain 4-digit, 2-digit and 2-digit numbers separated by hyphen.</p>
<p>Under the hood, the strategy first parses the regular expression into an intermediate representation (<code>Hir</code>) using the <a href="https://crates.io/crates/regex-syntax">regex-syntax</a> crate.
Then it <a href="https://github.com/proptest-rs/proptest/blob/0b2628c6ab74f6b2602c32532dea9909188f2910/proptest/src/string.rs#L176-L242">matches the nodes</a> of this representation
and returns a strategy that generates characters or bytes based on the expression.
For example,</p>
<ul>
<li><code>Literal('A')</code> will return <code>Just('A')</code>, where <a href="https://docs.rs/proptest/latest/proptest/strategy/struct.Just.html"><code>Just</code></a> is a strategy which always produces a single given value and never shrinks, or</li>
<li><code>Class(Digit)</code><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a><span class="footnote-content"><code>Digit</code> is here used for illustration purposes only. All character classes are already converted into their corresponding <code>char</code> ranges in Hir.</span></sup> will return a strategy that picks a random digit character from given <code>char</code> ranges using the approach described earlier.</li>
</ul>
<p>Often it’s a composition of nested strategies.
For example,</p>
<ul>
<li><code>Repetition(subexpr, kind)</code> will return a <code>Vec</code> strategy where elements (vectors of bytes) are produced by the strategy corresponding to <code>subexpr</code>;
the size of the vector is constrained by repetition <code>kind</code> and it is then flattened to a single vector of bytes, or</li>
<li><code>Alternation(subexprs)</code> will return a strategy that randomly picks one of the strategies that correspond to <code>subexprs</code> and produces a value from it.</li>
</ul>
<p>This is a nice example of a creative way how one can parametrize a strategy that should produce values under some constraints.
Another example could be generating HTTP requests specified by an <a href="https://www.openapis.org/">OpenAPI</a> specification:</p>
<pre class="language-rust"><code class="language-rust"><span class="token macro property">proptest!</span> <span class="token punctuation">{</span><br>    <span class="token attribute attr-name">#[test]</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">api_request</span><span class="token punctuation">(</span>request <span class="token keyword">in</span> <span class="token function">openapi</span><span class="token punctuation">(</span><span class="token macro property">include_str!</span><span class="token punctuation">(</span><span class="token string">"path/to/openapi.json"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// ...</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<p>This example shows this one technique:</p>
<ol>
<li>A creative, convenient way to communicate to the strategy how to produce complex values with desired constraints.</li>
</ol>
<h3 id="hashmaps">HashMaps <a class="header-anchor" href="#hashmaps">#</a></h3>
<p>Before looking at the strategy for <code>HashMap</code>, we have to first see the <a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/collection.rs#L552-L566">strategy</a> for generating <code>Vec</code>s. Fortunately, it is quite simple:</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">let</span> <span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>size<span class="token punctuation">.</span><span class="token function">start_end_incl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> max_size <span class="token operator">=</span> <span class="token function">sample_uniform_incl</span><span class="token punctuation">(</span>runner<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">let</span> <span class="token keyword">mut</span> elements <span class="token operator">=</span> <span class="token class-name">Vec</span><span class="token punctuation">::</span><span class="token function">with_capacity</span><span class="token punctuation">(</span>max_size<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token keyword">while</span> elements<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> max_size <span class="token punctuation">{</span><br>    elements<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>element<span class="token punctuation">.</span><span class="token function">new_tree</span><span class="token punctuation">(</span>runner<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>First, it samples the target size from the range provided by the user and then it fills the vector with elements produced by the strategy for elements (also provided by the user).</p>
<p>The actual implementation of the strategy for <code>HashMap</code> is a macro exhibition (<a href="https://github.com/proptest-rs/proptest/blob/eeb91cfb13408d10b9a475d2758fc81d6106551a/proptest/src/collection.rs#L416-L474">judge for yourself</a>),
but the idea is straightforward: Generate <code>Vec&lt;(K, V)&gt;</code> and <code>.into_iter().collect()</code> it to <code>HashMap&lt;K, V&gt;</code>.</p>
<p>This example only shows what we have already seen:
using other strategies as building blocks and using a different representation during the generation.
But here it is even more apparent.</p>
<h3 id="summary">Summary <a class="header-anchor" href="#summary">#</a></h3>
<p>Along with generation logic that is inherently specific to your case, consider also these general techniques:</p>
<ol>
<li>Use other strategies as building blocks.</li>
<li>Refine a random value according to the requirements specified by the strategy parameters.</li>
<li>Use a different representation during the generation. One for which strategies already exist or one that is easy to manipulate during generation (and potentially shrinking).</li>
<li>Bias towards supposed edge cases. But don’t overdo it.</li>
<li>Handle invalid values produced by the random generator. Try harder or fall back to producing at least something.</li>
<li>Provide a creative, convenient way to communicate to the strategy how to produce complex values with desired constraints.</li>
</ol>
<h2 id="shrinking-implementation">Shrinking implementation <a class="header-anchor" href="#shrinking-implementation">#</a></h2>
<p>Shrinking is the more complicated task from the two.
This is where choosing appropriate <a href="#internal-representation">internal representation</a> matters.
But there are also standard approaches that one can use for more complex cases.</p>
<p>Usually, the shrinking state machine will store</p>
<ul>
<li>the shrink action that is going to be applied, e.g. <code>Shrink::DeleteElement(usize)</code>, and</li>
<li>some current state, e.g. <code>State { removed_elements: HashSet&lt;usize&gt; }</code>.</li>
</ul>
<p>For undoing a shrink action during complication, you can choose to store one of these two:</p>
<ol>
<li>Shrink action that was made in the previous step.</li>
<li>The snapshot of the state in the previous step.</li>
</ol>
<p>Although (1) is simpler, sometimes reverting the previous shrink action to get to the previous state is just a little too hard or even unfeasible.
In those situations, using (2) to just restore the previous state is fine and worth the space.</p>
<p>Still remember the lattice illustration from earlier in this post?
In that picture, (1) represents going back over the shrinking edge that you took in the previous step, while (2) is just teleporting to the previous state.</p>
<p>It is also needed to somehow indicate that the shrinking is done.
In some cases, it is implicit (e.g., the index of the element to shrink is out of bounds);
in the others, it needs to be explicit by using <code>None</code> with <code>shrink: Option&lt;Shrink&gt;</code>.</p>
<p>The <em>simplification</em> more or less consists of these steps:</p>
<ol>
<li>Apply the current shrink action.</li>
<li>Store the shrink action or current state as “previous”.</li>
<li>“Increment” the shrink action (e.g., delete next element or start a new phase like shrinking the elements themselves).</li>
</ol>
<p>The <a href="https://github.com/proptest-rs/proptest/blob/0b2628c6ab74f6b2602c32532dea9909188f2910/proptest/src/collection.rs#L607-L651"><code>simplify</code></a> implementation for <code>Vec</code> illustrates this process well and in consumable form.</p>
<p>The <em>complication</em> is then undoing the previous shrink action or restoring the previous state.
Again, <a href="https://github.com/proptest-rs/proptest/blob/0b2628c6ab74f6b2602c32532dea9909188f2910/proptest/src/collection.rs#L653-L675"><code>complicate</code></a> for <code>Vec</code> as an example.</p>
<p>Many types have multiple “dimensions” to shrink.
Usually, they are <em>structure</em> and <em>elements</em>:</p>
<ul>
<li><code>Vec&lt;T&gt;</code> or <code>Matrix&lt;T&gt;</code> can be reduced in <em>size</em> and then in remaining <em>elements</em> of type <code>T</code>.</li>
<li>A graph can be reduced in <em>structure</em> (vertices and edges) and then in <em>weights</em> (on remaining vertices and edges).</li>
<li>An API request can be first stripped of <em>optional properties</em> and then get simplified <em>values</em> for the remaining.</li>
</ul>
<p>It is usually (always?) advantageous to first shrink the structure and then the elements
because after simplifying the structure there is less work on reducing the elements.
In fact, this is exactly what, for instance, the strategy for <code>Vec</code> <a href="https://github.com/proptest-rs/proptest/blob/0b2628c6ab74f6b2602c32532dea9909188f2910/proptest/src/collection.rs#L537-L540">does</a>.
It is either inconvenient or impossible to achieve this behavior without implementing a custom strategy,
at least this is what <a href="https://github.com/dimforge/nalgebra/blob/f5af5dbff2f0b3582e3874cecf1963578ea1f855/src/proptest/mod.rs#L281-L293">this comment</a> in <a href="https://crates.io/crates/nalgebra"><code>nalgebra</code></a> codebase suggests:</p>
<blockquote>
<p>Perhaps more problematic, however, is the poor shrinking behavior the current setup leads to.
Shrinking in proptest basically happens in “reverse” of the combinators, so
by first generating the dimensions and then the elements, we get shrinking that first
tries to completely shrink the individual elements before trying to reduce the dimension.
This is clearly the opposite of what we want. I can’t find any good way around this
short of writing our own custom value tree, which we should probably do at some point.</p>
<p> — Nalgebra proptest/mod.rs:281</p>
</blockquote>
<figure><img src="/static/img/structure-elements.png" style="max-width: 100%" alt="There may be preferred simplification order between the "dimensions" of the type.
"><figcaption><p>There may be preferred simplification order between the “dimensions” of the type.</p>
</figcaption></figure>
<h2 id="miscellaneous-remarks">Miscellaneous remarks <a class="header-anchor" href="#miscellaneous-remarks">#</a></h2>
<p>Putting more effort into making the shrinking process capable will pay off when one runs into test failures.
Minimizing the reproducer is an important part of property-based testing and fixing a bug with an example that is as small as possible is definitely easier than with a complicated monster.</p>
<p>Consider providing a specialized <code>Debug</code> implementation to aid diagnosis of the failure.
For example in gryf, the generated graph is wrapped in an adapter that prints the graph in DOT syntax which can be visualized by <a href="https://graphviz.org/">Graphviz</a>.
For the developer who is debugging their algorithm on edge cases, this is infinitely more useful than an internal – usually incomprehensible – representation of the graph storage implementation.</p>
<p>I find using the builder pattern to be a very clean way for specifying <em>optional</em> parameters.
Since the manual implementation of a strategy gives you full control over the type,
you can add setters taking <code>self</code> and returning the strategy with the parameter set accordingly.
In combination with <code>fn arb_foo() -&gt; FooStrategy</code>, this allows to parametrize the strategy like this:</p>
<pre class="language-rust"><code class="language-rust"><span class="token macro property">proptest!</span> <span class="token punctuation">{</span><br>    <span class="token attribute attr-name">#[test]</span><br>    <span class="token keyword">fn</span> <span class="token function-definition function">proptest</span><span class="token punctuation">(</span><br>        <span class="token comment">//                 vertices         edges</span><br>        graph <span class="token keyword">in</span> <span class="token function">arb_graph</span><span class="token punctuation">(</span><span class="token function">any</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">any</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">u16</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><br>            <span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><br>            <span class="token punctuation">.</span><span class="token function">connected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><br>            <span class="token punctuation">.</span><span class="token function">class</span><span class="token punctuation">(</span><span class="token class-name">GraphClass</span><span class="token punctuation">::</span><span class="token class-name">Bipartite</span><span class="token punctuation">)</span><br>    <span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token comment">// ...</span><br>    <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre>
<h2 id="conclusion">Conclusion <a class="header-anchor" href="#conclusion">#</a></h2>
<p>After reading this post, you hopefully have a better idea of how proptest strategies
work under the hood and know some general techniques on how to implement your own
manually.</p>
<p>I will once again repeat that the default approach for testing with proptest is
to use the standard strategies provided by the crate and compose them using
provided tools. Choosing the manual implementation should be considered
only if that brings substantial benefits in the quality of generated values, quality of shrinking
or easier maintenance if the value generation logic with all those combinators like <code>prop_map</code> or <code>prop_filter</code> went too wild.</p>
<p>In the end, I myself learned new things while writing this post
and will likely incorporate them into the implementation in <a href="https://github.com/pnevyk/gryf">gryf</a> at some point.</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>
Technically, you can also have multiple <code>ValueTree</code> implementations for a type.
But I am not sure where it would be useful in practice.
Apart from special adapters like <a href="https://docs.rs/proptest/latest/proptest/strategy/struct.NoShrink.html"><code>NoShrink</code></a>. <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>Finally I can use this term outside of the university! <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>This claim is not really true in general.
Possibly, there could exist a branch from one of the value’s ancestors which could lead to an even smaller reproducer but was not tried.
If this is true for your type, consider making the extra effort to make the simplification traverse all possible paths so you are guaranteed to get an actually minimal reproducer. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>
Unless you are the type of a programmer who <a href="https://github.com/rust-lang/regex/discussions/994#discussioncomment-5948689">writes code without bugs</a>. <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><code>Digit</code> is here used for illustration purposes only. All character classes are already converted into their corresponding <code>char</code> ranges in Hir. <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

</article>

 </main>
 <footer>
 <p class="copyright">Licensed under <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons</a> | Feel free to share</p>
 <div class="links">
 <a href="https://github.com/pnevyk" target="_blank"><i class="fa fa-github"></i></a>
 <a href="https://twitter.com/pnevyk" target="_blank"><i class="fa fa-twitter"></i></a>
 <a href="/feed.xml" target="_blank"><i class="fa fa-rss"></i></a>
 </div>
 </footer>

 <script src="/static/js/main.js"></script>
 <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
</body>
</html>
